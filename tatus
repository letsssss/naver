[1mdiff --git a/app/api/auth/me/route.ts b/app/api/auth/me/route.ts[m
[1mindex 3aa3fb0..36d9718 100644[m
[1m--- a/app/api/auth/me/route.ts[m
[1m+++ b/app/api/auth/me/route.ts[m
[36m@@ -1,213 +1,148 @@[m
[31m-import { NextResponse } from "next/server";[m
[31m-import { supabase } from '@/lib/supabase';[m
[31m-import { getTokenFromHeaders, getTokenFromCookies, verifyAccessToken } from "@/lib/auth";[m
[31m-import jwt from "jsonwebtoken";[m
[32m+[m[32mimport { NextResponse } from 'next/server';[m
[32m+[m[32mimport * as jose from 'jose';[m
[32m+[m[32mimport { cookies } from 'next/headers';[m
[32m+[m[32mimport { createClient } from '@supabase/supabase-js';[m
[32m+[m[32mimport { Database } from '@/types/supabase.types';[m
[32m+[m[32mimport { SUPABASE_URL, SUPABASE_ANON_KEY } from '@/lib/env';[m
 [m
[31m-// 타입스크립트 인터페이스 정의[m
[32m+[m[32m// DB 메모리 캐시 타입 정의[m
 interface MemoryUser {[m
   id: number;[m
   email: string;[m
[31m-  password: string;[m
[31m-  name: string;[m
[32m+[m[32m  name: string | null;[m
   role: string;[m
[32m+[m[32m  profileImage: string | null;[m
   createdAt: Date;[m
[31m-  updatedAt: Date;[m
 }[m
 [m
[31m-// JWT 시크릿 키 정의 (login 라우트와 동일한 키 사용)[m
[31m-const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';[m
[32m+[m[32m// 서버 메모리 내 사용자 캐시[m
[32m+[m[32mconst userCache: Record<string, { user: MemoryUser; timestamp: number }> = {};[m
 [m
[31m-// 개발 환경 확인 함수[m
[31m-const isDevelopment = () => !process.env.NODE_ENV || process.env.NODE_ENV === 'development';[m
[32m+[m[32m// 인메모리 캐시 TTL (5분)[m
[32m+[m[32mconst CACHE_TTL = 5 * 60 * 1000;[m
 [m
[31m-// Edge 브라우저 포함한 모든 브라우저에서 쿠키를 올바르게 설정하는 헬퍼 함수[m
[31m-function setAuthCookie(response: NextResponse, name: string, value: string, httpOnly: boolean = true) {[m
[31m-  response.cookies.set(name, value, {[m
[31m-    httpOnly,[m
[31m-    secure: process.env.NODE_ENV === 'production',[m
[31m-    sameSite: 'lax',[m
[31m-    maxAge: 60 * 60 * 24 * 7, // 7일 (초)[m
[31m-    path: '/',[m
[31m-  });[m
[32m+[m[32m/**[m
[32m+[m[32m * 쿠키에서 JWT 토큰을 추출하는 함수[m
[32m+[m[32m */[m
[32m+[m[32mfunction getTokenFromCookies() {[m
[32m+[m[32m  const cookieStore = cookies();[m
[32m+[m[32m  return cookieStore.get('token')?.value;[m
 }[m
 [m
[31m-// 메모리 기반 사용자 저장소 (독립적으로 유지)[m
[31m-export const memoryUsers: MemoryUser[] = [];[m
[31m-[m
[31m-// 개발 환경에서 메모리 사용자 추가 함수[m
[31m-export function addMemoryUser(user: Omit<MemoryUser, 'id' | 'createdAt' | 'updatedAt'>) {[m
[31m-  const newUser: MemoryUser = {[m
[31m-    ...user,[m
[31m-    id: memoryUsers.length + 1,[m
[31m-    createdAt: new Date(),[m
[31m-    updatedAt: new Date()[m
[31m-  };[m
[31m-  [m
[31m-  memoryUsers.push(newUser);[m
[31m-  console.log(`메모리 사용자 추가됨: ${newUser.email}, ID: ${newUser.id}`);[m
[31m-  return newUser;[m
[32m+[m[32m/**[m
[32m+[m[32m * JWT 토큰을 확인하고 페이로드를 반환하는 함수[m
[32m+[m[32m */[m
[32m+[m[32masync function verifyJwtToken(token: string) {[m
[32m+[m[32m  if (!token) return null;[m
[32m+[m
[32m+[m[32m  try {[m
[32m+[m[32m    const secret = new TextEncoder().encode(process.env.JWT_SECRET || 'your-secret-key');[m
[32m+[m[32m    const { payload } = await jose.jwtVerify(token, secret);[m
[32m+[m[32m    return payload;[m
[32m+[m[32m  } catch (error) {[m
[32m+[m[32m    console.error('JWT 검증 오류:', error);[m
[32m+[m[32m    return null;[m
[32m+[m[32m  }[m
 }[m
 [m
 // OPTIONS 메서드 처리 (CORS)[m
 export async function OPTIONS() {[m
   return new NextResponse(null, {[m
[31m-    status: 200,[m
[32m+[m[32m    status: 204,[m
     headers: {[m
       'Access-Control-Allow-Origin': '*',[m
[31m-      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',[m
[32m+[m[32m      'Access-Control-Allow-Methods': 'GET, OPTIONS',[m
       'Access-Control-Allow-Headers': 'Content-Type, Authorization',[m
     },[m
   });[m
 }[m
 [m
[31m-export async function GET(request: Request) {[m
[32m+[m[32m/**[m
[32m+[m[32m * 현재 로그인한 사용자 정보를 반환하는 API 엔드포인트[m
[32m+[m[32m */[m
[32m+[m[32mexport async function GET() {[m
   try {[m
[31m-    // 인증 헤더에서 토큰 확인[m
[31m-    const authHeader = request.headers.get('authorization');[m
[31m-    let token: string | undefined;[m
[31m-    [m
[31m-    if (authHeader && authHeader.startsWith('Bearer ')) {[m
[31m-      token = authHeader.split(' ')[1];[m
[31m-    } else {[m
[31m-      // 쿠키에서 토큰 확인[m
[31m-      const cookies = request.headers.get('cookie');[m
[31m-      if (cookies) {[m
[31m-        const cookiePairs = cookies.split('; ');[m
[31m-        const authTokenCookie = cookiePairs.find(c => c.startsWith('auth-token='));[m
[31m-        if (authTokenCookie) {[m
[31m-          token = authTokenCookie.split('=')[1];[m
[31m-        }[m
[31m-      }[m
[31m-    }[m
[32m+[m[32m    // 토큰 가져오기[m
[32m+[m[32m    const token = getTokenFromCookies();[m
     [m
[31m-    // 토큰이 없는 경우[m
     if (!token) {[m
[31m-      console.log("토큰 없음: 인증되지 않음");[m
[31m-      return NextResponse.json({ error: "인증되지 않음" }, { status: 401 });[m
[32m+[m[32m      return NextResponse.json([m
[32m+[m[32m        { error: '로그인이 필요합니다.' },[m
[32m+[m[32m        { status: 401 }[m
[32m+[m[32m      );[m
     }[m
[32m+[m
[32m+[m[32m    // 토큰 검증[m
[32m+[m[32m    const payload = await verifyJwtToken(token);[m
     [m
[31m-    try {[m
[31m-      // 토큰 검증[m
[31m-      const decoded: any = jwt.verify(token, JWT_SECRET);[m
[31m-      const userId = decoded.userId;[m
[31m-      [m
[31m-      // 개발 환경에서 테스트 사용자 허용[m
[31m-      if (isDevelopment() && memoryUsers.some(u => u.id === userId)) {[m
[31m-        const user = memoryUsers.find(u => u.id === userId);[m
[31m-        [m
[31m-        // 응답 생성[m
[31m-        const response = NextResponse.json({[m
[31m-          success: true,[m
[31m-          user,[m
[31m-          token // 클라이언트가 새로운 토큰을 저장할 수 있도록 다시 전달[m
[31m-        });[m
[31m-        [m
[31m-        // 쿠키 설정 - Edge 호환성을 위해 헬퍼 함수 사용[m
[31m-        setAuthCookie(response, 'auth-token', token);[m
[31m-        setAuthCookie(response, 'auth-status', 'authenticated', false);[m
[31m-        [m
[31m-        // 캐시 방지 헤더 추가[m
[31m-        response.headers.set('Cache-Control', 'no-cache, no-store, must-revalidate');[m
[31m-        response.headers.set('Pragma', 'no-cache');[m
[31m-        response.headers.set('Expires', '0');[m
[31m-        [m
[31m-        return response;[m
[31m-      }[m
[31m-      [m
[31m-      // 데이터베이스에서 사용자 조회[m
[31m-      const user = await prisma.user.findUnique({[m
[31m-        where: { id: userId },[m
[31m-        select: {[m
[31m-          id: true,[m
[31m-          email: true,[m
[31m-          name: true,[m
[31m-          role: true[m
[31m-        }[m
[31m-      });[m
[31m-      [m
[31m-      if (!user) {[m
[31m-        console.log("사용자를 찾을 수 없음:", userId);[m
[31m-        return NextResponse.json({ error: "사용자를 찾을 수 없음" }, { status: 404 });[m
[31m-      }[m
[31m-      [m
[31m-      console.log("사용자 인증 성공:", user.email);[m
[31m-      [m
[31m-      // 응답 생성[m
[31m-      const response = NextResponse.json({[m
[31m-        success: true,[m
[31m-        user,[m
[31m-        token // 클라이언트가 새로운 토큰을 저장할 수 있도록 다시 전달[m
[31m-      });[m
[31m-      [m
[31m-      // 쿠키 설정 - Edge 호환성을 위해 헬퍼 함수 사용[m
[31m-      setAuthCookie(response, 'auth-token', token);[m
[31m-      setAuthCookie(response, 'auth-status', 'authenticated', false);[m
[31m-      [m
[31m-      // 캐시 방지 헤더 추가[m
[31m-      response.headers.set('Cache-Control', 'no-cache, no-store, must-revalidate');[m
[31m-      response.headers.set('Pragma', 'no-cache');[m
[31m-      response.headers.set('Expires', '0');[m
[31m-      [m
[31m-      return response;[m
[31m-      [m
[31m-    } catch (e) {[m
[31m-      console.error("토큰 검증 오류:", e);[m
[31m-      [m
[31m-      // 개발 환경에서는 기본 사용자를 반환[m
[31m-      if (isDevelopment()) {[m
[31m-        console.log("개발 환경에서 기본 사용자(ID: 3)로 인증 진행");[m
[31m-        [m
[31m-        // 데이터베이스에서 기본 사용자 조회[m
[31m-        try {[m
[31m-          const devUser = await prisma.user.findUnique({[m
[31m-            where: { id: 3 }, // 기본 개발 사용자 ID[m
[31m-            select: {[m
[31m-              id: true,[m
[31m-              email: true,[m
[31m-              name: true,[m
[31m-              role: true[m
[31m-            }[m
[31m-          });[m
[31m-          [m
[31m-          if (devUser) {[m
[31m-            console.log("개발 환경 자동 인증 성공:", devUser.email);[m
[31m-            [m
[31m-            // 새로운 개발용 토큰 생성[m
[31m-            const devToken = jwt.sign([m
[31m-              { userId: devUser.id, email: devUser.email },[m
[31m-              JWT_SECRET,[m
[31m-              { expiresIn: '24h' }[m
[31m-            );[m
[31m-            [m
[31m-            // 응답 생성[m
[31m-            const response = NextResponse.json({[m
[31m-              success: true,[m
[31m-              user: devUser,[m
[31m-              token: devToken,[m
[31m-              devMode: true[m
[31m-            });[m
[31m-            [m
[31m-            // 쿠키 설정[m
[31m-            setAuthCookie(response, 'auth-token', devToken);[m
[31m-            setAuthCookie(response, 'auth-status', 'authenticated', false);[m
[31m-            [m
[31m-            // 캐시 방지 헤더 추가[m
[31m-            response.headers.set('Cache-Control', 'no-cache, no-store, must-revalidate');[m
[31m-            response.headers.set('Pragma', 'no-cache');[m
[31m-            response.headers.set('Expires', '0');[m
[31m-            [m
[31m-            return response;[m
[31m-          }[m
[31m-        } catch (dbError) {[m
[31m-          console.error("개발 환경에서 사용자 조회 실패:", dbError);[m
[32m+[m[32m    if (!payload || !payload.sub) {[m
[32m+[m[32m      return NextResponse.json([m
[32m+[m[32m        { error: '유효하지 않은 토큰입니다.' },[m
[32m+[m[32m        { status: 401 }[m
[32m+[m[32m      );[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    const userId = payload.sub;[m
[32m+[m
[32m+[m[32m    // 캐시에서 사용자 정보 확인[m
[32m+[m[32m    const cachedData = userCache[userId];[m
[32m+[m[32m    const now = Date.now();[m
[32m+[m
[32m+[m[32m    if (cachedData && now - cachedData.timestamp < CACHE_TTL) {[m
[32m+[m[32m      console.log('캐시에서 사용자 정보 반환:', userId);[m
[32m+[m[32m      return NextResponse.json({ user: cachedData.user });[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Supabase 클라이언트 생성 - 직접 createClient 사용[m
[32m+[m[32m    const supabase = createClient<Database>([m
[32m+[m[32m      SUPABASE_URL,[m
[32m+[m[32m      SUPABASE_ANON_KEY,[m
[32m+[m[32m      {[m
[32m+[m[32m        auth: {[m
[32m+[m[32m          persistSession: false,[m
[32m+[m[32m          autoRefreshToken: false[m
         }[m
       }[m
[31m-      [m
[31m-      return NextResponse.json({ error: "유효하지 않은 토큰" }, { status: 401 });[m
[32m+[m[32m    );[m
[32m+[m[41m    [m
[32m+[m[32m    // 사용자 정보 조회[m
[32m+[m[32m    const { data: userData, error } = await supabase[m
[32m+[m[32m      .from('users')[m
[32m+[m[32m      .select('id, email, name, role, profile_image, created_at')[m
[32m+[m[32m      .eq('id', userId)[m
[32m+[m[32m      .single();[m
[32m+[m[41m    [m
[32m+[m[32m    if (error || !userData) {[m
[32m+[m[32m      console.error('사용자 정보 조회 오류:', error);[m
[32m+[m[32m      return NextResponse.json([m
[32m+[m[32m        { error: '사용자 정보를 찾을 수 없습니다.' },[m
[32m+[m[32m        { status: 404 }[m
[32m+[m[32m      );[m
     }[m
[32m+[m
[32m+[m[32m    // 응답 형식에 맞게 형변환[m
[32m+[m[32m    const formattedUser: MemoryUser = {[m
[32m+[m[32m      id: userData.id,[m
[32m+[m[32m      email: userData.email,[m
[32m+[m[32m      name: userData.name,[m
[32m+[m[32m      role: userData.role,[m
[32m+[m[32m      profileImage: userData.profile_image,[m
[32m+[m[32m      createdAt: new Date(userData.created_at)[m
[32m+[m[32m    };[m
[32m+[m
[32m+[m[32m    // 캐시에 사용자 정보 저장[m
[32m+[m[32m    userCache[userId] = {[m
[32m+[m[32m      user: formattedUser,[m
[32m+[m[32m      timestamp: now[m
[32m+[m[32m    };[m
[32m+[m
[32m+[m[32m    return NextResponse.json({ user: formattedUser });[m
[32m+[m[32m  } catch (error) {[m
[32m+[m[32m    console.error('사용자 정보 조회 중 오류:', error);[m
     [m
[31m-  } catch (e) {[m
[31m-    console.error("인증 확인 오류:", e);[m
[31m-    return NextResponse.json({ error: "서버 오류" }, { status: 500 });[m
[32m+[m[32m    return NextResponse.json([m
[32m+[m[32m      { error: '서버 오류가 발생했습니다.' },[m
[32m+[m[32m      { status: 500 }[m
[32m+[m[32m    );[m
   }[m
 } [m
\ No newline at end of file[m
